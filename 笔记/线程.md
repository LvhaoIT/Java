# 线程

###### 进程：计算机cpu核心数，一个核心只能同时处理一个进程

###### 主频：调度进程，越高越快

###### 线程：一个核心内处理进程是可能是多条并行处理，这里面的一条就叫线程

###### 多线程：多线程是进程的支流，当分支过后，就互不相干，假设在进程上跑的代码是主程序，当其中的第三行代码是开启线程的，那么开启线程之后线程运行的代码就是与主程序并行（他们之间就互不相干了）



## 1.多线程的创建与启动

##### 它们通过java.lang.Thread类来实现

##### run()方法：想要在开启的多线程中运行的代码逻辑就写在run方法里。

##### start()方法：用来启动线程，本质上就开始运行run方法。



##### 多线程的异步：是指在主程序中启用多线程，后续的程序都是并行，所以会交叉输出，异步是相对于t.start来说的。



### 1.1通过继承Thread类来实现多线程

代码

```java
public class TestThread extends Thread {
    @Override
    public void run() {
        System.out.println("多线程运行的代码");
        for (int i = 0; i < 5; i++) {
            System.out.println("多线程：" + i);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        //通过继承Thread来开启线程
        Thread t = new TestThread();
        t.start();//开启线程
        System.out.println("============================");
        System.out.println("============================");
        System.out.println("============================");
    }
}


```



### 1.2通过Runnable接口来实现多线程

**1）定义子类，实现Runnable接口**

**2）子类中重写Runnable接口中的run方法**

**3）通过Thread类含参构造器创建线程对象**

**4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中**

**5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法**

代码

```java
public class TestRunnable implements Runnable {
    @Override
    public void run() {
        //Thread.currentThread().getName()获取当前线程的名称
        System.out.println(Thread.currentThread().getName() + "Runnable多线程多线程运行的代码");
        for (int i = 0; i < 5; i++) {
            System.out.println("Runnable多线程：" + i);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        
        Thread t1 = new Thread(new TestRunnable());//通过Runnable来实现
        t1.start();

        Thread t2 = new Thread(new TestRunnable(), "t-2");//通过Runnable来实现,该线程命名为t-2
        t2.start();
    }
}

```



## 2.继承方式和实现方式的联系与区别

#### 【区别】

**继承Thread： 线程代码存放在Thread子类run方法中。**

**实现Runnable： 线程代码存放在接口的子类run方法中。**

#### 【实现接口方式的好处】

**1）避免了单继承的局限性**

**2）多个线程可以共享同一个接口实现类的对象，非常是和多个相同进程来处理同一份资源**

一般使用实现接口的方式来实现多线程



## 3.Thread类的相关方法

**void start()；启动线程，并执行对象的run()方法**

**run()：线程在被调度时执行的操作**

**String getName()：返回线程名**

**void setName(String name)：设置该线程名称**

**static currentThread()：返回当前线程**

代码

```java
package 线程;

public class Test1 {
    public static void main(String[] args) {
        TestRun run0 = new TestRun();
        TestRun run1 = new TestRun();//多态，实现类实例化

        Thread t0 = new Thread(run0);//定义线程
        Thread t1 = new Thread(run1, "t-1");
        t0.setName("t-0");//修改t0线程名称
        System.out.println(t0.getName());
        System.out.println(t1.getName());

        t0.start();
        t1.start();

        System.out.println("============================");
        System.out.println("============================");
        System.out.println("============================");
    }
}

class TestRun implements Runnable {
    int count = 0;

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            count++;
            System.out.println("TestRun多线程：" + count);
        }
    }
}
```





## 4.线程优先级控制

**MAX_PRIOORITY (10);**

**MIN_PRIOORITY (1);**

**NORM_PRIOORITY (5);**

**涉及的方法**

**getPriority()： 返回线程优先值（如果没有设置，默认是5）**

```java
//测试
TestRun run0 = new TestRun();
Thread t0 = new Thread(run0);//定义线程
System.out.println("t0的优先级为:" + t0.getPriority());
```

**setPriorit(int newPriority) ：改变线程的优先级**

优先级只是说哪一个进程有较大的概率被执行

优先级是用数组1-10表示，数字越大优先级越高，